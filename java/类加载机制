Java类加载机制：加载阶段和连接阶段（Linking）的部分内容是交叉进行的。
1、加载：
	1、通过一个类的全限定名来获取定义此类的二进制字节流；
	2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
	3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；
2、连接
	1、验证：主要是验证二进制流数据是否符合Java JVM规范
	2、准备：主要是为类变量分配内存并设置类变量初始值，为类常量设置值
	3、解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程
3、初始化
	由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的。
	静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
	<clinit>()方法与实例构造器<init>()方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<clinit>()之前执行。
	<clinit>()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对静态变量的赋值操作，那么编译器可以不为这个类生产<clinit>()方法。
	执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。
	接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
	虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步
	
	虚拟机规范严格规定了有且只有5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
	1、遇到new,getstatic,putstatic,invokestatic这失调字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
	   生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段
	  （被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
	2、使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
	3、当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
	4、当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
	5、当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，
	   并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。
4、使用
	1、对象的初始化是先初始化成员变量再执行构造方法
	2、非静态块和成员变量地位一致
5、卸载
